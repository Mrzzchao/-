高阶函数
---
可以将函数作为参数进行传递或者返回的一种函数，是JS设计模式的基础

单例模式
---
应用场景：
适合只需要一个实例，例如webQQ的登录框，点击登录只需要一个登录框

策略模式
---
一个基于策略模式的程序至少由两部分组成。
* 第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。
* 第二个部分是环境类 Context， Context 接受客户的请求，随后
把请求委托给某一个策略类。要做到这点，说明 Context 中要维持对某个策略对象的引用

就是将实现与调用进行分离，客户只需要知道如何对Context调用即可

代理模式
---
* 虚拟代理：代理函数可以根据特定情况来执行原函数，避免过多的代码扰乱原函数，违反单一性原则，增加了耦合性

* 缓存代理：缓存代理可以为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递进来的参
数跟之前一致，则可以直接返回前面存储的运算结果


迭代器模式
---
现在的语言或者框架，都已经封装好了迭代器，只要调用即可，但是当这种迭代器无法满足我们的需求时，就可以自定义一个迭代器

目的：
解决繁琐的__if else__ 语句，使得代码更简易


发布-订阅模式（观察者模式）
---
* 就像关注微信公众号每天接受推送一样，微信公众号就是发布者，我们就是订阅者。
* 主要应用于异步编程
* 全局时间的命名冲突（还未理解）


命令模式
---
把需要执行的操作封装成命令，然后将命令安装到请求对象上，当对象发送请求时，就可以将命令发送给接收者，然后执行相应的操作，从而减少了请求者与接收者的耦合。

* 应用场景：队列、撤销和重做。

组合模式
---
当多个对象执行的操作相似时，将所有对象看成是相同的，无论对象是组合的，还是节点对象。
* 应用场景：树的扫描（文件扫描）

模板方法模式
---
就是Java里面的抽象类与子类的形式，将公共方法放到父对象的原型对象里，然后子对象的原型指向父对象的原型，达到继承的效果，子对象的特殊实现可以重写父对象的方法
* 应用场景：HttpServlet

享元模式
---
是一种用于性能优化的模式，解决了由于大量构造相似对象而造成的内存占用过高问题。所以把具有相同特点的状态（属性）存在对象内部进行共享，需要改变的是外部状态
* 内部状态储存于对象内部
* 内部状态可以被一些对象共享
* 内部状态独立于具体的场景，通常不会改变
* 外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享

* 应用场景：文件上传，

#### 对象池
例子：
> 比如我们组人手一本《JavaScript 权威指南》，从节约的角度来讲，
这并不是很划算，因为大部分时间这些书都被闲置在各自的书架上，所以我们一开始就只买一本，
或者一起建立一个小型图书馆（对象池），需要看书的时候就从图书馆里借，看完了之后再把书
还回图书馆。如果同时有三个人要看这本书，而现在图书馆里只有两本，那我们再马上去书店买
一本放入图书馆

* 应用场景：HTTP连接池和数据库连接池

职责链模式
---
使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间
的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止

例子：
> 如果早高峰能顺利挤上公交车的话，那么估计这一天都会过得很开心。因为公交车上人
实在太多了，经常上车后却找不到售票员在哪，所以只好把两块钱硬币往前面递。除非
你运气够好，站在你前面的第一个人就是售票员，否则，你的硬币通常要在 N 个人手上
传递，才能最终到达售票员的手里

优点:
> 请求发送者只需要知道链中的第
一个节点，从而弱化了发送者和一组接收者之间的强联系。如果不使用职责链模式，那么在公交
车上，我就得先搞清楚谁是售票员，才能把硬币递给他

每一个节点都知道自己要干什么，如果请求不在自己的职责范围，那就把他传给定义好的下一个职责节点，直到找到能处理该请求的节点为止（最后定义一个默认的尾节点，处理意外输入）。

**类似原型链、作用域链、冒泡的传递思想**

中介者模式
---
降低甚至接触对象间的耦合，将对象间的处理操作委托给中介者处理，所以当对象有状态改变时，就可以把自己作为参数传给中介对象，中介对象就可以根据所有跟自己绑定的对象进行相关的处理，从而每个对象只需和中介对象打交道即可。

例子：
> 我们想象一下机场的指挥塔，如果没有指挥塔的存在，每一架飞机
要和方圆 100 公里内的所有飞机通信，才能确定航线以及飞行状况，后果是不可想象的。现实中
的情况是，每架飞机都只需要和指挥塔通信。指挥塔作为调停者，知道每一架飞机的飞行状况，
所以它可以安排所有飞机的起降时间，及时做出航线调整

作用：
> 解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的
相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知
中介者对象即可

装饰者模式
---
给对象动态地增加职责的方式称为装饰者（decorator）模式
简单来说就是将各种各样的函数功能都以一条函数链的形式添加到原函数对象的前面或者后面，令执行原函数时，会从函数链的首部一次执行每个功能

例子：
> 玩LOL时，会有升级点技能的情况，我们选择点什么技能，会导致不同的能力效果。这时每个技能点都是一个函数，当我们每点一个技能点的时候，我们就会先执行前面已经点的技能点，例如，沙皇的Q与E都是要先点W才能加点，因为那都是在W有沙兵的基础上释放的。所以呢，我们点Q和E的时候就会先执行我们先加点过的W技能，这就是装饰者的表现形式。

作用：
> 能够不更改原函数的代码实现，而选择将需要添加的功能以装饰者模式的形式增加到函数链中，维护了开放与封闭的原则。

状态模式(有待理解)
---
状态模式的关键是区分事物内部的状态，事物内部状态的改变往往会带来事物的行为改变
将每个状态封装成一个类，这个类有着该状态下应执行的行为，并且将每个类的实例作为原对象的属性，可以通过调用原对象的属性方法，来分别执行每个状态事件。

适配器模式
---
当我们试图调用模块或者对象的某个接口时，却发现这个接口的格式并不符合目前的需求。
这时候有两种解决办法，第一种是修改原来的接口实现，但如果原来的模块很复杂，或者我们拿
到的模块是一段别人编写的经过压缩的代码，修改原接口就显得不太现实了。第二种办法是创建
一个适配器，将原接口转换为客户希望的另一个接口，客户只需要和适配器打交道

例子：
> 港式的电器插头比大陆的电器插头体积要大一些。如果从香港买了一个 Mac book，我们
会发现充电器无法插在家里的插座上，为此而改造家里的插座显然不方便，所以我们需要一个
适配器
